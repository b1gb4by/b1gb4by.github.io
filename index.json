[{"categories":["Kubernetes"],"content":"Karpenter について深堀りします","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"先日、AWS re:Invent にて Kubernetes クラスターで Node の自動スケーリングをする Karpenter が GA になりました. 今回は、それについて深堀りしてみます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:0:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"はじめにこれは Kubernetes Advent Calendar 2021 18 日目の記事です. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:1:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Karpenter とはKarpenter は、「Just-in-time Nodes for Any Kubernetes Cluster」 と公式で記載されている通り、スケジュールが不能な Pod に対して、瞬時に新しい Node をプロビジョニングする機能を提供します. それにより、Kubernetes クラスター上でワークロードを実行する際の効率とコスト改善をゴールとしています. Karpenter の動作は以下の通りになります. Kubernetes スケジューラがスケジューリング不能とマークした Pod を監視する Pod から要求された以下のスケジューリング制約の評価 リソース要求 Node セレクタ アフィニティ トレラント トポロジー拡散制約 Pod の要件を満たす Node のプロビジョニング 新しい Node で実行する Pod のスケジューリング Node が不要になったら削除する Karpenter の利用方法について Karpenter は 2021 年 12 月 現在、AWS のみをサポートしています. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:2:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Kubernetes におけるオートスケールKubernetes には、Pod と Node それぞれにオートスケールする機能が提供されています. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:3:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"PodPod には、以下の 2 種類のスケール方法があります. 水平スケール (Horizontal Pod Autoscaler)Pod の水平スケールは、Pod 数を増やすことにより処理性能を向上させるスケール方法です. CPU やメモリなど、ユーザが独自に設定したメトリクスなども判断の材料として使えます. Pod 数は以下の計算式で算出されます. 希望するレプリカ数 = ceil[\u003c現在の Pod数\u003e * (\u003c現在の指標値 / \u003cターゲットとする指標値\u003e)] 垂直スケール (Vertical Pod Autoscaler)Pod が利用可能なリソースを増やすことで処理性能を向上させるスケール方法です. こちらは、CPU やメモリを判断材料に使用します. どちらかと言うとリソース使用率の最適化を行っているイメージです. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:3:1","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"NodeNode の水平オートスケーラー (Cluster Autoscaler)ワーカー Node の台数を増やすことによって処理性能を向上させるスケール方法です. Pod の水平スケールなどと連携することも可能です. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:3:2","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"インストール方法Karpenter は、Helm Chart でクラスタにインストールされます. Karpenter はさらに、IAM Roles for Service Accounts (IRSA)を必要とします. 現在、Karpenter を使用する際に必要なユーティリティは以下の通りです. AWS CLI kubectl the Kubernetes CLI eksctl the CLI for AWS EKS helm the package manager for Kubernetes AWS への Karpenter のインストール方法は、こちらの公式ドキュメントの 「Getting Started with Karpenter on AWS」 を参考にすると良いと思います. Karpenter の Helm Chart はこちらから確認することができます. Terraformを用いたインストール Terraform を使用したインストール方法もあります.詳しくはこちらを参照してください. 概要図は下図の通りです。 ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:4:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"プロビジョナーの設定Karpenter の仕事は、スケジュールできない Pod を処理する Node を追加し、その Node で Pod をスケジュールし、不要になったら Node を削除することです. Karpenter を設定するには、Karpenter がスケジューリング不能な Pod と期限付き Node を管理する方法を定義するプロビジョナーを作成します. 以下は、Karpenter のプロビジョナーについて知っておくと良いと思います. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:5:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Unschedulable podsKarpenter は、ステータス条件 Unschedulable=True を持つ Pod のみをプロビジョニングしようとします. これは、kube-scheduler が既存の容量に Pod をスケジュールすることに失敗したときに設定されます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:5:1","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Provisioner CRKarpenter では、プロビジョニング構成を指定するために、Provisioner というカスタムリソースを定義しています. 各プロビジョナーは個別の Node セットを管理しますが、Pod はそのスケジューリング制約をサポートする任意のプロビジョナーにスケジュールすることができます. プロビジョナーには、プロビジョニング可能な Node と Node の属性（Node を削除するためのタイマーなど）に影響を与える制約が含まれています. 以下が プロビジョナーのリソースになります. apiVersion:karpenter.sh/v1alpha5kind:Provisionermetadata:name:defaultspec:ttlSecondsUntilExpired:2592000ttlSecondsAfterEmpty:30taints:- key:example.com/special-tainteffect:NoSchedulelabels:billing-team:my-teamrequirements:- key:\"node.kubernetes.io/instance-type\"operator:Invalues:[\"m5.large\",\"m5.2xlarge\"]- key:\"topology.kubernetes.io/zone\"operator:Invalues:[\"us-west-2a\",\"us-west-2b\"]- key:\"kubernetes.io/arch\"operator:Invalues:[\"arm64\",\"amd64\"]- key:\"karpenter.sh/capacity-type\"operator:Invalues:[\"spot\",\"on-demand\"]provider:{} spec.ttlSecondsUntilExpiredは、コントローラが Node を終了するまでに待つ秒数で、Node の作成時から計測されます. これは、最終的に一貫した Node アップグレード、メモリリーク保護、破壊テストのような機能を実装するのに便利です. このフィールドが設定されていない場合、有効期限切れによる終了は無効になります. spec.ttlSecondsAfterEmptyは、Node が空になったことを検出した時点から、コントローラが Node を削除しようとするまでに待つ秒数です. Node は、デーモンセットを除いて、その Node にスケジュールされている Pod がない場合、空であると見なされます. spec.requirementsは、プロビジョニングされた Node のパラメータを制約します. nodeAffinity や nodeSelector と組み合わせることも可能です. 演算子 { In, NotIn } は、値を含めたり除外したりするためにサポートされています. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:5:2","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Node のデプロビジョニングKarpenter では、不要になった Node を以下のように削除しています. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:6:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"FinalizerKarpenter は、作成する各 Node にファイナライザービットを配置します。 これらの Node を削除するリクエスト（TTL や手動での kubectl による Node 削除など）が来ると、Karpenter は Node をコード化し、すべての Pod を排出して EC2 インスタンスを終了させ、Node オブジェクトを削除する. Karpenter は、Node を適切に削除するために必要なすべてのクリーンアップ作業を処理します. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:6:1","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Node ExpiryNode の有効期限値 (ttlSecondsUntilExpired)に達すると、その Node は（まだワークロードを実行していても）Pod から排出され、削除されます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:6:2","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Empty NodesKarpenter が管理する Node で稼働している最後のワークロード Pod がなくなると、その Node には emptiness タイムスタンプが付与されます。その「Node が空になる」有効期限 (ttlSecondsAfterEmpty) 達すると、ファイナライズがトリガーされます. Nodeを削除する方法について Karpenter が Node を削除する方法の詳細については、Node のデプロビジョニングの詳細を参照してください. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:6:3","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Node のアップグレードNode をアップグレードする簡単な方法は、ttlSecondsUntilExpired を設定することです。Node は設定された期間後に終了し、より新しい Node と入れ替わります. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:7:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"制約条件プロビジョナーで定義された制約や、デプロイされる Pod から要求された制約がないため、Karpenter はクラウドプロバイダが利用できる機能全体から選択されます. Node は、任意のインスタンスタイプを使用して作成し、任意のゾーンで実行することができます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:8:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"スケジューリングKarpenter は、Kubernetes のスケジューラーが unschedulable とマークした Pod をスケジュールします. スケジューリング制約と起動容量を解決した後、Node を作成し、Pod をバインドします. このステートレスなアプローチは、レースコンディションを回避し、パフォーマンスを向上させるのに役立ちます. 起動した Node に何か問題があれば、Kubernetes は自動的に新しい Node に Pod を移行します.Karpenter が Node を立ち上げると、その Node は Kubernetes のスケジューラーがその上でをスケジュールすることも可能になります. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:9:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"クラウドプロバイダーKarpenter は、関連するクラウドプロバイダーに新しい Node のプロビジョニングの要求を行います. 最初にサポートされるクラウドプロバイダーは AWS ですが、Karpenter は他のクラウドプロバイダーでも動作するように設計されています. Kubernetes のよく知られたラベルを使用しながら、プロビジョナーは、クラウドプロバイダーに固有のいくつかの値を設定することができます. 個人でプロバイダーの開発する場合は、リポジトリのpkg/cloudprovider/配下に作成します. ディレクトリ構造は以下の通りです. fakeディレクトリは、参考例として用意されています. . ├── aws │ ├── apis │ │ └── v1alpha1 │ └── fake ├── fake ├── metrics └── registry まず、pkg/cloudprovider/registry配下で、クラウドプロバイダー毎に以下の以下のファイルを作成することで登録ができます. // +build \u003cYOUR_PROVIDER_NAME\u003e import ( \"github.com/aws/karpenter/pkg/cloudprovider/\u003cYOUR_PROVIDER_NAME\u003e\" ) func NewCloudProvider() cloudprovider.CloudProvider { return \u003cYOUR_PROVIDER_NAME\u003e.NewCloudProvider() } また、pkg/cloudprovider配下で、クラウドプロバイダーごとに環境に合わせて作成します. fake ディレクトリを確認すると以下のファイルが用意されています. その他の必要な情報は環境に合わせて追加すると良いです. . ├── cloudprovider.go └── instancetype.go ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:10:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"Cluster Autoscaler との違いKarpenter と同様に、Kubernetes Cluster Autoscaler は、現在のキャパシティでは対応できない Pod の実行要求が来たときに、Node を追加するように設計されています. Cluster Autoscaler は Kubernetes プロジェクトの一部であり、ほとんどの主要な Kubernetes クラウドプロバイダーが実装しています. プロビジョニングを見直すことで、Karpenter は以下の改善を提供しています. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:11:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"クラウドの柔軟性を活かした設計Karpenter は、AWS で利用できるあらゆる種類のインスタンスに効率的に対応できる能力を備えています. Cluster Autoscaler は、もともと何百ものインスタンスタイプ、ゾーン、購入オプションに対応できるような柔軟性を持って構築されたものではありません. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:11:1","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"グループレスの Node プロビジョニングKarpenter は、Node グループのようなオーケストレーションの仕組みを使わずに、各インスタンスを直接管理します. これにより、キャパシティが利用できない場合、数分ではなくミリ秒単位で再試行することができます. また、何百もの Node グループを作成することなく、多様なインスタンスタイプ、アベイラビリティゾーン、および購入オプションを活用することができます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:11:2","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"スケジューリングの実施Cluster Autoscaler は、作成した Node に Pod をバインドしません. その代わり、Node がオンラインになった後に同じスケジューリング決定を行うために kube-scheduler に依存します.Karpenter が起動した Node には、すぐにその Pod がバインドされます。kubelet` はスケジューラーや Node の準備が整うのを待つ必要がありません. イメージの事前プルも含め、コンテナランタイムの準備をすぐに開始できます.これにより、Node の起動レイテンシを数秒短縮することができます. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:11:3","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["Kubernetes"],"content":"所感今回は、Karpenter について少し深堀りしてみました. 個人的には、GKE Autopilot の動的 Node プロビジョニングプロセスと同じなのかなと思っています. Karpenter はそのツールの OSS 版と言えると思います. GKE Autopilot と同様に、Karpenter はスケジューリング不能な Pod の仕様を観測し、集約されたリソース要求を計算し、すべての Pod の実行に必要な容量を持つ基礎的な計算サービス（Amazon EC2 など）に要求を送信します. また、Karpenter では、カスタムリソースを定義して、以下の Node のプロビジョニング構成を指定することができます. 構成を柔軟に変更できる点は、かなり大きいメリットだと感じました. インスタンスサイズ/タイプ、トポロジー(ゾーンなど) アーキテクチャ(arm64、amd64 など) ライフサイクルタイプ(スポット、オンデマンド、プリエンプティブなど) 一方、Karpenter は、Node が不要になった場合、デプロビジョンを行うこともできます. これは、Node の有効期限設定 (ttlSecondsUntilExpired) または Karpenter プロビジョニングされた Node 上で実行されている最後のワークロードが終了したとき (ttlSecondsAfterEmpty) に決定することができます. この 2 つのイベントのどちらかがトリガーとなり、Node をコード化し、Pod を排出し、基盤となるコンピュートリソースを終了させ、Node オブジェクトを削除するファイナライゼーションが行われます. このデプロビジョニング機能は、Node を最新の AMI で最新の状態に保つためにも使用できます. Karpenter を使えば、Node のプロビジョニング、オートスケール、アップグレードをオフロードして、アプリケーションの実行に集中することができると思います. Karpenter はあらゆる種類の Kubernetes アプリケーションで動作しますが、特に、大量の多様な計算リソースを迅速にプロビジョニングおよびデプロビジョニングする必要があるユースケースで優れたパフォーマンスを発揮すると思います. (機械学習モデルのトレーニング、シミュレーションの実行、複雑な金融計算を行うバッチジョブなど) 現在は、AWS のみでしか動作しませんが今後の動向には注目していきたいと思います. また、時間があれば他クラウドへの実装などもしてみようと思います. ","date":"2021-12-16","objectID":"/2021/12/karpenter-deep-dive/:12:0","tags":["AWS","EKS","Kubernetes","Auto Scaling"],"title":"Karpenter Deep Dive","uri":"/2021/12/karpenter-deep-dive/"},{"categories":["security"],"content":"2段階認証アプリの引き継ぎ方法について纏めたドキュメント","date":"2021-10-04","objectID":"/2021/10/authenticator/","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"Google Authenticator の機種変更時の引き継ぎ方法について説明します. また、個人的に推奨している Microsoft Authenticator についても解説します. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:0:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"概要近年、セキュリティの強化として2 段階認証の導入が推奨され、多くの方が SMS 認証や Google Authenticator などの認証アプリケーションをスマートフォンなどにインストールしているかと思います. しかし、認証アプリは機種変更などをした際に正しい引き継ぎ手順を踏まなければ、認証アプリにログインできなくなります.それによって苦汁を舐めた人たちも多くいるのではないでしょうか. そのような事態にならないためにも、正しい手順を理解し、スムーズに引き継げるようにしましょう. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:1:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"そもそも 2 段階認証って？2 段階認証はその名の通り、「2 度の認証を行う」ことです. 従来の 1 つの認証方法を使うよりはるかにセキュアに管理する事ができます. 2 段階認証には、様々な方法があります. SMS, メールなどを用いる場合 認証サーバなどで特定の文字列などが発行され、送信されます. ユーザはそれを画面上で入力します. 2 段階認証アプリケーションを用いる場合 アプリケーション上でワンタイムのセキュリティコードが自動的に生成され、そのコードを画面上に入力します. 2 段階認証アプリケーションについて 2 段階認証アプリは別名、TOTP (Time-based One-Time Password) アプリとも呼ばれます. その他にも、「トークン」のような小さなハードウェアや、生体情報を用いる場合もあります. 2 段階認証アプリケーションは複数の企業が開発していますが、これらはOATH (initiative for Open AuTHentication) 規格と呼ばれる共通の規格を採用しており、基本的にはどのアプリケーションでも同じように利用が可能です. 一部例外について 銀行では OATH 規格が登場する前から提供されている製品(RSA SecureID, DIGIPASSなど)を利用している場合もあります. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:2:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"2 段階認証を扱う上での注意点いくらセキュアな機能だとしても注意するべき点はいくつかあります. 2 段階目の認証として最も利用されているのはスマートフォンだと思います. スマートフォンの電話番号宛に SMS が届き、そのコードを利用したり、キャリアメールアドレスに送られるコードを利用したりするため、スマートフォンの紛失・盗難時にログインできなくなります. これは、ワンタイムパスワードを用いる場合も同じことが言えます. Google Authenticator を利用している場合は、スマートフォンにインストールして利用しているため、紛失・盗難時には同じくログインすることができません. また、スマートフォンの機種を変更した場合も引き継ぎを正しく行っていなければアプリケーションをインストールしても復元することができません. これらを回避する方法としては以下の通りです. 複数の認証方法を設定しておく SMS + 2 段階認証アプリケーション 2 段階認証アプリケーション + メール etc… 引き継ぎの際、2 段階認証の設定を無効化(解除)しておく ","date":"2021-10-04","objectID":"/2021/10/authenticator/:3:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"引き継ぎ方法 (Google Authenticator)Google Authenticator を新しいデバイスへ引き継ぐ方法について解説します. 以前までは、アプリケーションに登録している 2 段階認証を全て無効化する必要がありましたが、現在は引き継ぐ前のデバイスでアカウント情報をエクスポートし、 それを新しいデバイスでインポートすることでアカウントを移行することができます. それぞれのデバイスでの手順は以下の通りです. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:4:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"iOS 移行前のデバイス Google Authenticator を起動 起動したアプリケーションの右上のメニューボタン...をタップし、「アカウントのエクスポート」を選択 エクスポート画面で、右下「続行」ボタンをタップ 指紋認証、FaceID、または端末に設定している PIN（パスコード）を入力して本人確認を実行 移行させるアカウントを選択して、「エクスポート」をタップ 移行用 QR コードが表示されたら準備完了 新しいデバイス Google Authenticator を起動し、「開始」をタップ 左下「既存のアカウントをインポートしますか？」をタップ 右下「QR コードをスキャン」をタップ エクスポート時に作成した移行用 QR コードを読み込む ","date":"2021-10-04","objectID":"/2021/10/authenticator/:4:1","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"Android 移行前のデバイス Google Authenticator を起動 起動したアプリケーションの右上のメニューボタン...をタップし、「アカウントの移行」を選択 エクスポート画面で、右下「アカウントのエクスポート」ボタンをタップ 本人確認を実行 「次へ」をタップ 移行用 QR コードが表示されたら準備完了 新しいデバイス Google Authenticator を起動し、「使ってみる」をタップ 左下「既存のアカウントをインポートしますか？」をタップ 右下「QR コードをスキャン」をタップ エクスポート時に作成した移行用 QR コードを読み込む 上記の手順を実行後、「インポート完了」と表示されれば引き継ぎは完了です. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:4:2","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"Microsoft Authenticator の利用上記では Google Authenticator を解説しましたが、私はMicrosoft Authenticatorを使用しています. 理由としては以下の通りです. バックアップ機能が搭載されていない 登録されているアプリケーションを並び替えると UI が壊れる 同一アプリケーションが複数表示される (誤って消すと両方とも消える) スマートフォン・アプリケーションでしか利用できない 非常にシンプルなのですが、UI が壊れるのも耐え難く、最大の理由としては「バックアップ機能が搭載されていない」という点です. 万が一、デバイスが起動しなくなった際の再設定などの手間を考えると、あまり使いやすいとは言えません. 一方で、Microsoft Authenticator だと、Microsoft アカウントをアプリと同期することでバックアップが可能です. 詳しい方法に関しては、こちらを参照ください. iOS 版の Microsoft Authenticator について iOS 版では iCloud でバックアップを行うため、iCloud のアカウントが必要となります. しかし、Microsoft Authenticator も Google Authenticator と同じく、スマートフォン・アプリケーションでしか利用できません. 「PC でも使用したい！」と言う方は、Twilio社のAuthyを使用することをおすすめします. Authy の利用方法について Authy を利用する場合は、別途 Authy のアカウントを作成する必要があります. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:5:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["security"],"content":"まとめ今回は、2 段階認証の仕組みと、認証アプリケーションの引き継ぎ方法などについて解説しました. 2 段階認証アプリケーションを使用することで、アカウントの情報をよりセキュアに管理することができる反面、きちんと管理する必要があります. 特に 2 段階認証設定後のバックアップコードの管理には十分、注意してください. 実体が無いとは言え、重要な資産なので、この記事を参考に大切に保管しましょう. ","date":"2021-10-04","objectID":"/2021/10/authenticator/:6:0","tags":["authenticator","2factor","microsoft","google"],"title":"2段階認証アプリの引き継ぎ方法","uri":"/2021/10/authenticator/"},{"categories":["device"],"content":"所持しているデバイス情報","date":"2021-09-28","objectID":"/2021/09/device-configuration/","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"所有しているデバイスの詳細情報について説明します. ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:0:0","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"Macbook Pro (13-inch, 2019) 項目 内容 OS macOS 12.0.1 (Monterey) 21A559 x86_64 CPU Intel i7-8569U (8) @ 2.80GHz GPU Intel Iris Plus Graphics 655 Memory 16 GB 2133 MHz LPDDR3 Terminal iTerm2 Terminal Font FiraCode Nerd Font Shell fish v3.3.1 ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:1:0","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"自作 PC自作 PC には、2 つの OS がインストールされています。 ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:2:0","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"共通 項目 内容 Motherboard ROG STRIX H370-F GAMING (ASUSTeK COMPUTER INC.) CPU Intel(R) Core(TM) i5-8500 CPU @ 3.00GHz GPU NVIDIA GeForce GTX 1060 6GB (MSI Co., Ltd.) Memory DDR4-2666MHz 8×4GB (Corsair Inc.) Storage(OS) Crucial MX500 500×2GB (Micron Technology, Inc.) Storage Western Digital Blue: 6TB, Green: 3×2TB (Western Digital Corporation) ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:2:1","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"OS (1) 項目 内容 OS Windows 11 Pro (64bit) Terminal Windows Console Terminal Font FiraCode Shell PowerShell v7.1.4 ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:2:2","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":["device"],"content":"OS (2) 項目 内容 OS Manjaro Linux x86_64 Terminal xfce4-terminal Terminal Font FiraCode Nerd Font Shell bash 5.1.8 ","date":"2021-09-28","objectID":"/2021/09/device-configuration/:2:3","tags":["Linux","Mac","Windows","Device"],"title":"所有しているデバイスについて","uri":"/2021/09/device-configuration/"},{"categories":null,"content":"moreroについて","date":"2021-07-13","objectID":"/about/","tags":["profile","portfolio"],"title":"WHORU?","uri":"/about/"},{"categories":null,"content":"1. お前、誰？ 兵庫出身の東京に住む、ソフトウェアエンジニアです. 最近は、KaaS (Kuberentes As a Service) 開発をメインに行っています. たまに趣味で DJ をしています. ","date":"2021-07-13","objectID":"/about/:1:0","tags":["profile","portfolio"],"title":"WHORU?","uri":"/about/"},{"categories":null,"content":"2. アイコンについてSouth Park Avatar Creator で作成しています. ","date":"2021-07-13","objectID":"/about/:2:0","tags":["profile","portfolio"],"title":"WHORU?","uri":"/about/"},{"categories":null,"content":"moreroの職務経歴書","date":"2021-07-01","objectID":"/resume/","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"基本情報 項目 内容 氏名 岡本 泰典 (オカモト タイスケ) 生年月日 1996/12/02 最終学歴 大阪工業大学 情報科学部 ネットワークデザイン学科 (旧: 情報ネットワーク学科) ","date":"2021-07-01","objectID":"/resume/:1:0","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"保有スキル Golng でのバックエンド開発、設計、テスト、運用、保守 クリーンアーキテクチャを意識したコーディング TDD でのテストコード開発 Kubernetes での開発、設計、テスト、運用、保守 Prometheus, Grafana を使用した監視メトリクスの収集 CI / CD の環境構築、運用 DRM の資格(CWIP: Certified Widevine Implementation Partner)の保有 ","date":"2021-07-01","objectID":"/resume/:2:0","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"技術スタック カテゴリ 技術スタック Programing langage / Library etc… Golang, Python, Java, PHP, C, Solidity, Zig(individual), gRPC Framework Gin, Falcon, Spring Boot Infrastructure GCP Middleware Redis Database MySQL, Cloud SQL Data analytics BigQuery Environment setup Ansible, Cloud Build. Docker, Terraform(individual) Container Orchestration Kubernetes, Rancher, CloudStack Monitoring Prometheus, Grafana Service Mesh Istio, Linkerd(individual) CI CircleCI, GitHub Actions ","date":"2021-07-01","objectID":"/resume/:3:0","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"職務経歴詳細","date":"2021-07-01","objectID":"/resume/:4:0","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"株式会社 IDC フロンティア (2021/09 ~ 現在)① Kubernetes as a Service (KaaS) 開発 プロジェクト規模 約 40 名 (グループ: 1 ~ 4 名) 役割 機能検討、設計、コーディング、その他、調査、研究など プロジェクト詳細 自社クラウド及び各社クラウドサービスと Kubernetes as a Service を連携するアプリケーションの開発 CSI Driver/Cloud Controller Manager/Ingress Controller といった Kubernetes とクラウドを連携させるための Kubernetes コンポーネントの開発 Kubernetes の各種機能や実装についての調査・研究 Rancher などの Kubernetes クラスター管理ツールの各種機能や実装についての調査・研究 Kubernetes as a Service に求められる Cloud Native な各種ソフトウェア/サービスに関する調査・研究・開発 ","date":"2021-07-01","objectID":"/resume/:4:1","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"パペルック株式会社 (2021/02 ~ 2021/08)① 自社の商品発注管理システムの開発・運用 プロジェクト規模 約 2~4 名 役割 テックリード、機能検討、設計、コーディング、レビュー プロジェクト詳細 Go 言語での API 開発 GCP 内で完結するサービスの運用 CloudBuild + CloudRun での CI/CD の構築、及び開発スピードの促進 自社で使用している EC プラットフォーム(Shopify)との連携 ② 中国、韓国 EC サイトなどとの連携システムの開発・運用 プロジェクト規模 個人開発 役割 機能検討、設計、コーディング アライアンスとの仕様検討、及び交渉 プロジェクト詳細 Go 言語による API, バッチ処理, Webhook の実装 バッチ処理では並行処理を使用し、2~3 万件/日の登録処理を実施 Slack との連携を行い、エラー発生時などの早期検知を実現 また、以下の業務を兼務 社内ネットワークの整備、及び保守 D2C 事業でのクライアントのサイトの構築、及び運用、保守 Google App Script + Google Analytics を使用し、自社 EC サイトの日時レポートの自動化 ","date":"2021-07-01","objectID":"/resume/:4:2","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"株式会社ビデオマーケット (2019/04 ~ 2021/01)① 配信サービス内の再生基盤のリニューアル プロジェクト規模 約 20 名 役割 API の機能検討、設計、コーディング、レビュー クラウドインフラの設計、コーディング、レビュー 監視ツールの導入 CI/CD 内への脆弱性チェックを導入 プロジェクト詳細 既存で動いている PHP の再生基盤を Golang へリプレイス GKE を使用したマイクロサービス化 Kustomize を用いた Kubernetes におけるマニフェストの環境差分の管理コストの削減 サービスメッシュを活用し、マイクロサービス間の通信をセキュアに保つ 使用用途を切り分け、それぞれに BigQuery, Redis など適した DB を導入 Grafana, Prometheus を用いたアラートの実装 また、業務の一環として以下の DRM の資格を取得 CWIP (Certified Widevine Implementation Partner) 2020 年 12 月 合格 ","date":"2021-07-01","objectID":"/resume/:4:3","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"業務外活動","date":"2021-07-01","objectID":"/resume/:5:0","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"技術コーチ / Relie inc. (2022/01 ~ 現在) 役割 技術研修の実施 エンジニアリングにおける課題解決の支援 ","date":"2021-07-01","objectID":"/resume/:5:1","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"総合プラットフォームの開発 / Relie inc. (2021/07) プロジェクト規模 約 3 名 役割 API の設計、コーディング、開発、レビュー DB の構築、及びマイグレーションの自動化 クラウドサーバの構築、運用、保守 仕様技術 Golang GCP (GAE, CloudSQL, BigQuery) 友人が起業した会社のサービス開発のバックエンド全般をサポート. また、インフラの構築を担当. ","date":"2021-07-01","objectID":"/resume/:5:2","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"音声プラットフォームの開発 (2019/07 ~ 2019/11) プロジェクト規模 約 2 名 役割 独自メディア再生プレイヤーの設計、実装、テスト 仕様技術 HTML, CSS, JavaScript 友人が起業した会社のサービスの開発の一部をサポート。 ","date":"2021-07-01","objectID":"/resume/:5:3","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":null,"content":"LP サイトの作成 (2017/10 ~ 2017/12) プロジェクト規模 個人開発 役割 WordPress の構築、運用、保守 LP サイトの作成 仕様技術 WordPress, PHP, JavaScript, CSS, MySQL 友人が起業した会社の LP の作成から公開、運用を全て行う。 ","date":"2021-07-01","objectID":"/resume/:5:4","tags":null,"title":"職務経歴書","uri":"/resume/"},{"categories":["music"],"content":"作成したSpofityプレイリストの紹介","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"以下のプレイリストを現在、作成しています. TPO に合わせて様々なジャンルの音楽をお楽しみ下さい. playlist name genres Today in life is a collection of the past that I have always spent. House It eases my heart. House What’s up meeeeeen !? Dubstep, Bass The best part about me is I am not you. Hip-hop (Global) You can make something of your life. It just depends on your drive. Japanese Hip-hop Why don’t you sit and have something to drink? Lo-Fi Japanese Hip-hop Kawaii Kawaii Kawaiiiiiii Kawaii Bass I won’t be a rock star. I will be a legend. Rock ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:0:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"1. Today in life is a collection of the past that I have always spent. ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:1:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"2. It eases my heart. ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:2:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"3. What’s up meeeeeen !? ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:3:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"4. The best part about me is I am not you. ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:4:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"5. You can make something of your life. It just depends on your drive. ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:5:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"6. Why don’t you sit and have something to drink? ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:6:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"7. Kawaii Kawaii Kawaiiiiiii ","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:7:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"},{"categories":["music"],"content":"8. I won’t be a rock star. I will be a legend.","date":"2021-06-08","objectID":"/2021/06/my-spotify-playlists/:8:0","tags":["Spotify","music"],"title":"俺の Spotify プレイリスト","uri":"/2021/06/my-spotify-playlists/"}]